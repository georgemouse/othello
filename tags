!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ABPara	search.h	/^typedef struct ABPara{$/;"	s
ABPara	search.h	/^}ABPara;$/;"	t	typeref:struct:ABPara
ABSearch	search.cpp	/^Action AISeacher::ABSearch(Color caller,Color player,bool isMax,const Board* state,int alpha,int beta,int depth){$/;"	f	class:AISeacher
AISeacher	search.h	/^class AISeacher{$/;"	c
Action	search.h	/^typedef std::pair<int,int> Action;$/;"	t
BLACK	board.h	/^enum Piece{EMPTY='-',BLACK='X',WHITE='O'};$/;"	e	enum:Piece
BOARD_H	board.h	2;"	d
Board	board.cpp	/^Board::Board(const Board& that){$/;"	f	class:Board
Board	board.cpp	/^Board::Board(int boardSize){$/;"	f	class:Board
Board	board.h	/^class Board{$/;"	c
Color	board.h	/^typedef char Color;$/;"	t
EMPTY	board.h	/^enum Piece{EMPTY='-',BLACK='X',WHITE='O'};$/;"	e	enum:Piece
GAME_H	game.h	2;"	d
Game	game.h	/^class Game{$/;"	c
HVH	game.h	/^	enum Mode{HVM=1,HVH,MVM};$/;"	e	enum:Game::Mode
HVM	game.h	/^	enum Mode{HVM=1,HVH,MVM};$/;"	e	enum:Game::Mode
Hashkey	board.h	/^typedef long long int Hashkey;$/;"	t
MVM	game.h	/^	enum Mode{HVM=1,HVH,MVM};$/;"	e	enum:Game::Mode
Mode	game.h	/^	enum Mode{HVM=1,HVH,MVM};$/;"	g	class:Game
Move	board.h	/^	Move():pos(0,0){}$/;"	f	class:Move
Move	board.h	/^	Move(int x,int y):pos(x,y){}$/;"	f	class:Move
Move	board.h	/^class Move{$/;"	c
MoveList	board.h	/^typedef std::vector<Move> MoveList;$/;"	t
OBJS	Makefile	/^OBJS=main.o game.o board.o search.o$/;"	m
Piece	board.h	/^enum Piece{EMPTY='-',BLACK='X',WHITE='O'};$/;"	g
Position	board.h	/^	Position(int x,int y):x(x),y(y){}$/;"	f	class:Position
Position	board.h	/^class Position{$/;"	c
PositionList	board.h	/^typedef std::list<Position> PositionList;$/;"	t
Rival	board.h	/^	inline Color Rival(Color myColor)const{return (myColor==BLACK)?WHITE:BLACK;}$/;"	f	class:Board
Rival	board.h	/^inline Color Rival(Color myColor){$/;"	f
SEARCH_H	search.h	2;"	d
SRC	Makefile	/^SRC=main.cpp game.cpp board.cpp search.cpp$/;"	m
TAR	Makefile	/^TAR=othello$/;"	m
WHITE	board.h	/^enum Piece{EMPTY='-',BLACK='X',WHITE='O'};$/;"	e	enum:Piece
XSquares	board.cpp	/^MoveList Board::XSquares=MoveList(4);$/;"	m	class:Board	file:
XSquares	board.h	/^	static MoveList XSquares;$/;"	m	class:Board
addOffset	board.h	/^	void addOffset(Position offset){validOffsets.push_back(offset);}$/;"	f	class:Move
alpha	search.h	/^	int alpha;$/;"	m	struct:ABPara
beta	search.h	/^	int beta;$/;"	m	struct:ABPara
board	board.h	/^	Color* board;$/;"	m	class:Board
board	game.h	/^	Board board;$/;"	m	class:Game
boardHashkey	board.h	/^	Hashkey boardHashkey;$/;"	m	class:Board
boardSize	board.h	/^	int boardSize;$/;"	m	class:Board
caller	search.h	/^	Color caller;$/;"	m	struct:ABPara
cls	game.cpp	/^char cls[]={0x1b,'[','2','J'};$/;"	v
corners	board.h	/^	static MoveList corners;$/;"	m	class:Board
countPiece	board.cpp	/^void Board::countPiece(int& blackPiece,int& whitePiece) const{$/;"	f	class:Board
depth	search.h	/^	int depth;$/;"	m	struct:ABPara
doMove	board.cpp	/^void Board::doMove(Color my,Move& move){$/;"	f	class:Board
eval	board.cpp	/^int Board::eval(Color caller) const{$/;"	f	class:Board
getOffsets	board.h	/^	PositionList& getOffsets(){return validOffsets;}$/;"	f	class:Move
getValidMove	board.cpp	/^void Board::getValidMove(Color my,MoveList& validMove) const{$/;"	f	class:Board
hasClosure	board.cpp	/^bool Board::hasClosure(Color my,Position pos,const Position& offset)const{$/;"	f	class:Board
humanSelect	game.cpp	/^Move& Game::humanSelect(){$/;"	f	class:Game
initSpecialLocation	board.cpp	/^void Board::initSpecialLocation(){$/;"	f	class:Board
initTranpositionTable	board.cpp	/^void Board::initTranpositionTable(){$/;"	f	class:Board
isFull	board.cpp	/^bool Board::isFull() const{$/;"	f	class:Board
isMax	search.h	/^	bool isMax;$/;"	m	struct:ABPara
isValidPosition	board.cpp	/^bool Board::isValidPosition(const Position& p) const{$/;"	f	class:Board
loop	game.cpp	/^void Game::loop(){$/;"	f	class:Game
machineSelect	game.cpp	/^Move& Game::machineSelect(Color my){$/;"	f	class:Game
main	main.cpp	/^int main(int argc, char* argv[]){$/;"	f
max	search.cpp	5;"	d	file:
maxDepth	main.cpp	/^int AISeacher::maxDepth=4;$/;"	m	class:AISeacher	file:
maxDepth	search.h	/^	static int maxDepth;$/;"	m	class:AISeacher
mode	game.h	/^	int mode;$/;"	m	class:Game
operator +	board.h	/^	Position operator +(const Position& that){$/;"	f	class:Position
operator +=	board.h	/^	Position& operator +=(const Position& that){$/;"	f	class:Position
piece	board.h	/^	Color piece(Position p) const {return board[rc(p.x,p.y)];}$/;"	f	class:Board
pieceHashKey	board.cpp	/^Hashkey* Board::pieceHashKey=0;$/;"	m	class:Board	file:
pieceHashKey	board.h	/^	static Hashkey* pieceHashKey;$/;"	m	class:Board
player	search.h	/^	Color player;$/;"	m	struct:ABPara
pos	board.h	/^	Position pos;$/;"	m	class:Move
positionCount	board.cpp	/^int Board::positionCount(Color my,MoveList& positions) const{$/;"	f	class:Board
print	board.cpp	/^void Board::print() const{$/;"	f	class:Board
printPlayer	game.cpp	/^void Game::printPlayer(Color color){$/;"	f	class:Game
ranGenkey	board.cpp	/^long long ranGenkey(){$/;"	f
rc	board.h	4;"	d
result	board.cpp	/^Board* Board::result(Color my,Move& move) const{$/;"	f	class:Board
searcher	game.h	/^	AISeacher searcher;$/;"	m	class:Game
selectMode	game.cpp	/^void Game::selectMode(){$/;"	f	class:Game
setPiece	board.cpp	/^void Board::setPiece(const Position& pos,Color c){$/;"	f	class:Board
showStatics	game.cpp	/^void Game::showStatics(){$/;"	f	class:Game
state	search.h	/^	const Board* state;$/;"	m	struct:ABPara
utility	board.cpp	/^int Board::utility(Color caller) const{$/;"	f	class:Board
validMove	game.h	/^	std::vector<Move> validMove;$/;"	m	class:Game
validOffsets	board.h	/^	PositionList validOffsets;$/;"	m	class:Move
x	board.h	/^	short x;$/;"	m	class:Position
y	board.h	/^	short y;$/;"	m	class:Position
~Board	board.cpp	/^Board::~Board(){$/;"	f	class:Board
